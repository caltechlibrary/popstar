#!/usr/bin/env osascript -s o                            # -*- mode: apples -*-
# Summary: get the iCloud link for a Shortcut.
#
# Copyright 2024 California Institute of Technology.
# License: Modified BSD 3-clause – see file "LICENSE" in the project website.
# Website: https://github.com/caltechlibrary/popstar

use AppleScript version "2.5"
use framework "Foundation"
use scripting additions

# ~~~~ Global constants ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Get a reference to the application (needed for use with Foundation classes).
property current_app: a reference to current application

# Max time (in sec) to wait for the Shortcuts app to launch.
property max_app_startup_wait: 15

# Delay (in sec) introduced between steps when picking/clicking on menu items.
property gui_delay: 0.25

# Max time (in sec) to wait for Shortcuts to write a link to the clipboard.
property max_clipboard_wait: 5


# ~~~~ Helping hands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Return the basename of a file path, without directory components or suffix.
on basename(file_path)
	set fp to current_app's NSString's stringWithString:file_path
	return fp's stringByDeletingPathExtension()'s lastPathComponent() as text
end basename

# Return the file name of this script as a string, minus the extension.
on script_name()
    tell application "System Events"
        set path_alias to path to me
		set file_name to name of path_alias
		return my basename(file_name)
    end tell
end script_name

# Return true if the str is one of the values in the list_of_strings.
on member(str, list_of_strings)
	ignoring case
		set arr to current_app's |NSArray|'s arrayWithArray:list_of_strings
		return (arr's containsObject:str) as boolean
	end ignoring
end member

# Return a string consisting of "character" repeated "count" times.
on char_string(char, num)
    set c to current_app's NSString's stringWithString:char
    set blank to current_app's NSString's |string|()
    set str to blank's stringByPaddingToLength:num withString:c startingAtIndex:0
    return str as text
end char_string

# Percent-encode the given string and return it.
on percent_encoded(orig_string)
    set str to current_app's NSString's stringWithString:orig_string
    set encoded_str to str's ¬
		stringByAddingPercentEncodingWithAllowedCharacters:(current_app's ¬
		    NSCharacterSet's URLQueryAllowedCharacterSet)
    return encoded_str as text
end percent_encoded

# Quit and restart application, wait to see it launched, and bring it to the
# front. Only waits for a limited time, in case something is wrong.
on restart_app(app_name)
	tell application app_name
		quit saving yes
	end tell
	set times_left to max_app_startup_wait * 2     # Done in 0.5 sec steps.
	# This roundabout approach of testing process names is because the more
	# direct "repeat until application app_name is running" causes errors.
	repeat while times_left > 0
		launch application app_name
		delay 0.5
		tell application "System Events"
			if (count of (every process whose name is app_name)) > 0 then
				exit repeat
			end if
		end tell
		set times_left to (times_left - 1)
	end repeat
	if times_left ≤ 0 then
		my alert("timed out waiting for " & app_name & " to launch.")
		my fail()
	end if
end launch_app

# Return a list of known Shortcut names.
on known_shortcuts()
	local orig_delims, shell_output, shortcuts_list
	set orig_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to (ASCII character 13)
	try
		# It is incredible that the MacOS Shortcuts app does not have a way to
		# get this info via AppleScript, and you have to resort to this.
		set shell_output to do shell script "shortcuts list"
	on error msg number code
		if the code is not -128 then
			my alert("unable to get a list of known shortcuts: " ¬
				& msg & " (error code " & code & ")")
			my fail()
		end if
	end try
	set shortcuts_list to text items of shell_output
	set AppleScript's text item delimiters to orig_delims
	return shortcuts_list
end known_shortcuts

# Print an error message.
on alert(msg)
	log "‼️ " & script_name() & " error: " & msg
end alert

# Exit with an non-zero status code. The status code returned to the parent
# shell is always 1. (Seems to be a limitation of osascript.)
on fail()
	# The AppleScript "error" command prints a message and always exits the
	# script with status code 1 (regardless of the value for the parameter
	# "number".) It also prints confusing other text and numbers, and IMHO the
	# result is confusing. The following is a ridiculously kludgy hack to try
	# to wipe that message it prints.
	set blank_str to my char_string(" ", 70)
	set backspace_str to my char_string(ASCII character 8, 70)
	set carriage_return to ASCII character 13
	set blank_text to backspace_str & blank_str & carriage_return
	error blank_text number 1
end fail


# ~~~~ Main body ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

on print_usage()
	set my_name to my script_name()
	set name_len to (count of characters of my_name)
	set padding to my char_string(" ", name_len)
	log "Usage: " & script_name() & " shortcut_name"
	log "       " & script_name() & " -h"
	log ""
	log "If given the argument -h, this program prints a usage summary"
	log "and exits."
	log ""
	log "Otherwise, this program expects a single argument: the name of a"
	log "Shortcut, and returns an iCloud sharing link for that Shortcut. It"
	log "does this by invoking the Shortcuts app and asking it for the iCloud"
	log "link for the 'shortcut_name' given as the argument on the command"
	log "line. The named Shortcut must be defined among the Shortcuts"
	log "available to the user account running this program, or an error will"
	log "result."
	log ""
	log "Note that due to limitations in controlling the MacOS Shortcuts app"
	log "programmatically, the approach used by this program involves GUI"
	log "scripting. Consequently, while it runs, you will see windows and"
	log "dialogs appear and disappear on your computer. This is normal."
end print_usage

on run argv
	# Do sanity checks and handle early exits.
	if (count of argv) is 0 then
		my print_usage()
		return
	end if
	repeat with arg in argv
		if my member(arg, {"help", "-h", "--help"}) then
			my print_usage()
			return
		end if
	end repeat
	if (count of argv) > 1 then
		my alert("given too many arguments.")
		my print_usage()
		my fail()
	end if

	# Check that the argument is a Shortcut name, not a file name. If it's
	# a file name, assume that the file's basename is the Shortcut name;
	# e.g., "My shortcut.shortcut" is assumed to be "My shortcut".
	set shortcut_name to my basename(first item of argv)

	# Make sure this Shortcut is actually defined.
	if not my member(shortcut_name, my known_shortcuts()) then
		my alert("cannot find '" & shortcut_name & "' among known Shortcuts.")
		my fail()
	end if

	# Things behave more predictably if we close & restart the Shortcuts app.
	my restart_app("Shortcuts")

	# Open the desired shortcut in the Shortcuts app.
	set encoded_name to my percent_encoded(shortcut_name)
	open location "shortcuts://open-shortcut?name=" & encoded_name

	# Clear the clipboard, so that we can tell when new content appears.
	set the clipboard to ""

	# Invoke the Shortcuts menu item to copy the iCloud link. There's no way
	# to do it directly, so we have to resort to GUI scripting. <blech>
	tell application "System Events"
		tell application process "Shortcuts"
			set frontmost to true
			tell menu bar item "File" of menu bar 1
				pick
				tell menu 1
					tell menu item "Share"
						pick
						delay gui_delay
						tell menu 1
							pick
							click menu item "Copy iCloud Link"
							delay gui_delay
						end tell
					end tell
				end tell
			end tell
		end tell
	end tell

	# Selecting the the iCloud link menu item causes the Shortcuts app to show
	# a dialog, and we need to click the "Share" button in that dialog.
	delay gui_delay * 2
	tell application "System Events"
		tell application process "Shortcuts"
			keystroke return
		end tell
	end tell
	
	# Shortcuts will write the link to the clipboard, but it takes time.
	# We have no way to know when it's there except by checking.
	set times_left to max_clipboard_wait * 2
	set clipboard_contents to ""
	repeat while times_left > 0
		delay 0.5
		set clipboard_contents to the clipboard as text
		if clipboard_contents is not "" then
			exit repeat
		end if
		set times_left to (times_left - 1)
	end repeat

	# Sanity check: do we have a URL in the clipboard?
	if clipboard_contents does not start with "https://" then
		# Clear the clipboard in case something unexpected got written to it.
		set clipboard_contents to ""
		my alert("failed to get an iCloud link for " & shortcut_name)
		my fail()
	end if

	# Close the app, and return the value on the clipboard
	tell application "Shortcuts"
		quit saving yes
	end tell

	return clipboard_contents
end run
